/*
 * Copyright (c) 2016, Linaro Limited
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <err.h>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <csignal>

/* OP-TEE TEE client API (built by optee_client) */
#include <tee_client_api.h>

#include <chaincode_tee_ree_communication.h>
#include <coffee_tracking_chaincode.h>

//#include <grpcpp/grpcpp.h>
//#include "invocation.grpc.pb.h"

using namespace std;

bool set_function(char *function, TEEC_Operation *op){
    //memcpy(function, "create789ABCDEF01234\1", 21);
    memcpy(function, "create", 6);
    op->params[0].tmpref.buffer = function;
    op->params[0].tmpref.size = FCT_SIZE;
    return true;
}

bool set_args(struct arguments *arguments_data){
    memset(arguments_data->arguments[0], 0, ARG_SIZE);
    memcpy(arguments_data->arguments[0], "peter", 5);
    memset(arguments_data->arguments[1], 0, ARG_SIZE);
    memcpy(arguments_data->arguments[1], "0", 1);
    return true;
}

bool handle_invocation_response(TEEC_Operation *op){
    
    struct invocation_response *invocation_response_data;
    invocation_response_data = (struct invocation_response *)(op->params[3].memref.parent->buffer);
    char response[RESPONSE_SIZE]; 
    memset(response, 0, RESPONSE_SIZE);
    memcpy(response, invocation_response_data->execution_response,
            strlen(invocation_response_data->execution_response));
    
    cout<<"HANDLE INVOCATION RESPONSE"<<std::endl;
    for(int i=0; i<strlen(invocation_response_data->execution_response); i++){
        cout<<response[i]<<"\\";
    }
    cout<<std::endl;

    return true;
}

bool handle_get_state_request(TEEC_Operation *op, TEEC_SharedMemory *data){
    struct key_value *key_value_data;
    key_value_data = (struct key_value *)(op->params[3].memref.parent->buffer);
    char key[KEY_SIZE];
    memset(key, 0, KEY_SIZE);
    memcpy(key, key_value_data->key, strlen(key_value_data->key));

    cout<<"HANDLE GET STATE REQUEST"<<std::endl;
    cout<<"Key value1 : "<<key<<std::endl;

    std:string get_state_response = "";

    key_value_data = (struct key_value *)data->buffer;
    memset(key_value_data, 0, sizeof(key_value));
    memcpy(key_value_data->value, get_state_response.c_str(), get_state_response.length());
    
    cout<<"Key value2 : "<<key_value_data->value<<std::endl;

    return true;

}

bool handle_put_state_request(TEEC_Operation *op, TEEC_SharedMemory *data){

    struct key_value *key_value_data;
    key_value_data = (struct key_value *)(op->params[3].memref.parent->buffer);
    char key[KEY_SIZE];
    char value[VAL_SIZE];
    memset(key, 0, KEY_SIZE);
    memcpy(key, key_value_data->key, strlen(key_value_data->key));
    memset(value, 0, VAL_SIZE);
    memcpy(value, key_value_data->value, strlen(key_value_data->value));
    
    cout<<"HANDLE PUT STATE REQUEST"<<std::endl;
    cout<<"Key value : "<<key<<std::endl;
    cout<<"Value : "<<value<<std::endl;

    std::string put_state_response = "OK";                           
    /* write ack of putState to shared memory */
    if(put_state_response.length() + 1 > ACK_SIZE) {
        return false;
    }

struct acknowledgement *acknowledgement_data = (struct acknowledgement *)data->buffer;
    memset(acknowledgement_data, 0, sizeof(acknowledgement));
    memcpy(acknowledgement_data->acknowledgement, put_state_response.c_str(), put_state_response.length());

    return true;

}


int main(void)
{
	TEEC_Result res = TEEC_SUCCESS;
	TEEC_Context ctx;
	TEEC_Session sess;
	TEEC_Operation op;
	TEEC_UUID uuid = TA_COFFEE_CHAINCODE_UUID;
    TEEC_SharedMemory data;
    TEEC_SharedMemory data2;
	uint32_t err_origin;
    bool success = true;

	/* Initialize a context connecting us to the TEE */
	res = TEEC_InitializeContext(NULL, &ctx);
	if (res != TEEC_SUCCESS)
		errx(1, "TEEC_InitializeContext failed with code 0x%x", res);

	/*
	 * Open a session to the "hello world" TA, the TA will print "hello
	 * world!" in the log when the session is created.
	 */
	res = TEEC_OpenSession(&ctx, &sess, &uuid,
			       TEEC_LOGIN_PUBLIC, NULL, NULL, &err_origin);
	if (res != TEEC_SUCCESS)
		errx(1, "TEEC_Opensession failed with code 0x%x origin 0x%x",
			res, err_origin);

	/*
	 * Execute a function in the TA by invoking it, in this case
	 * we're incrementing a number.
	 *
	 * The value of command ID part and how the parameters are
	 * interpreted is part of the interface provided by the TA.
	 */

	/* Clear the TEEC_Operation struct */
	memset(&op, 0, sizeof(op));

	/*
	 * Prepare the argument. Pass a value in the first parameter,
	 * the remaining three parameters are unused.
	 */
	op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INOUT, TEEC_VALUE_OUTPUT, TEEC_MEMREF_WHOLE, TEEC_MEMREF_WHOLE);
	
    /* allocate shared memory used for second paramter */
    size_t structure_sizes[] = { sizeof(struct key_value), sizeof(struct acknowledgement), sizeof(struct invocation_response), sizeof(struct arguments) };
   cout<<"SIZE List "<<endl;
   cout<<sizeof(struct key_value)<<endl;
   cout<<sizeof(struct acknowledgement)<<endl;
   cout<<sizeof(struct invocation_response)<<endl;
   cout<<sizeof(struct arguments)<<endl;
    data.size = sizeof(struct arguments);
    data.flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
    
    data2.size = sizeof(struct arguments);
    data2.flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
    res = TEEC_AllocateSharedMemory(&ctx, &data);
    if (res != TEEC_SUCCESS) {
        TEEC_CloseSession(&sess);
		errx(1, "TEEC_AllocateSharedMemory failed with code 0x%x", res);
    }
    res = TEEC_AllocateSharedMemory(&ctx, &data2);
    op.params[2].memref.parent = &data;
    op.params[3].memref.parent = &data2;
    memset(data.buffer, 0, data.size);
    memset(data2.buffer, 0, data.size);

    /* set first parameter: function name */
    char *function;
    function = (char *)calloc(FCT_SIZE, sizeof(char)); 
    success = set_function(function, &op);
    if(!success){
		errx(1, "failed with set function");
        goto cleanup;
    }

    /* set third parameter: arguments */
    struct arguments *arguments_data;
    arguments_data  = (struct arguments *)data.buffer; 
    success = set_args(arguments_data);
    if(!success){
		errx(1, "failed with set args");
        goto cleanup;
    }


    /* 
     * call chaincode inside OP-TEE
     * TA_CHAINCODE_CMD_INIT_INVOKE indicates that any old context inside the chaincode TA must be cleared 
     */
    res = TEEC_InvokeCommand(&sess, TA_CHAINCODE_CMD_INIT_INVOKE, &op, &err_origin);
    if (res != TEEC_SUCCESS) {
		errx(1, "failed TEEC_InvokeCommand with %x",res);
        goto cleanup;
    }
    while(true) {
        switch(op.params[1].value.a) {
            case INVOCATION_RESPONSE: {
                cout<<"while : invoc_res"<<endl;
                success = handle_invocation_response(&op);
                goto cleanup;
            }
            case GET_STATE_REQUEST: {
                cout<<"while : get_state"<<endl;
                success = handle_get_state_request(&op, &data2);
                if(!success){
                    goto cleanup;
                }
                break;
            }
            case PUT_STATE_REQUEST: {
                cout<<"while : put_state"<<endl;
                success = handle_put_state_request(&op, &data2);
                if(!success){
                    goto cleanup;
                }
                break;
            }
            case ERROR: {
                cout<<"while : error"<<endl;
                success = false;
                goto cleanup;
            }
            default: {  
                cout<<"while : default"<<endl;
                success = false;
                goto cleanup;
            }
        }

        /* 
         * call chaincode inside OP-TEE
         * TA_CHAINCODE_CMD_RESUME_INVOKE indicates that     the chaincode execution in the chaincode TA must be resume    d based on the stored context 
         */

        res = TEEC_InvokeCommand(&sess, TA_CHAINCODE_CMD_RESUME_INVOKE, &op, &err_origin);
        printf(" state : %x ",res);
        if (res != TEEC_SUCCESS) {
            cout<<"res error"<<endl;
            goto cleanup;
        }
    }

cleanup:
    free(function);
    TEEC_ReleaseSharedMemory(&data);
    TEEC_CloseSession(&sess);
    TEEC_FinalizeContext(&ctx);
    if(res != TEEC_SUCCESS || !success){
        cerr<<"Invalid close"<<endl;
        printf("%x %d",res, success);
        return -1;
    }

	return 0;
}
